{"ast":null,"code":"import { transformProps } from '../../render/html/utils/transform.mjs';\nimport { appearAnimationStore } from './store.mjs';\nimport { appearStoreId } from './store-id.mjs';\nvar handoffFrameTime;\nfunction handoffOptimizedAppearAnimation(id, name,\n/**\n * Legacy argument. This function is inlined apart from framer-motion so\n * will co-ordinate with Shuang with how best to remove this.\n */\n_value,\n/**\n * This function is loaded via window by startOptimisedAnimation.\n * By accepting `sync` as an argument, rather than using it via\n * import, it can be kept out of the first-load Framer bundle,\n * while also allowing this function to not be included in\n * Framer Motion bundles where it's not needed.\n */\nframe) {\n  var storeId = appearStoreId(id, transformProps.has(name) ? \"transform\" : name);\n  var appearAnimation = appearAnimationStore.get(storeId);\n  if (!appearAnimation) return 0;\n  var animation = appearAnimation.animation,\n    startTime = appearAnimation.startTime;\n  var cancelOptimisedAnimation = function cancelOptimisedAnimation() {\n    appearAnimationStore.delete(storeId);\n    /**\n     * Animation.cancel() throws so it needs to be wrapped in a try/catch\n     */\n    try {\n      animation.cancel();\n    } catch (e) {}\n  };\n  if (startTime !== null) {\n    /**\n     * We allow the animation to persist until the next frame:\n     *   1. So it continues to play until Framer Motion is ready to render\n     *      (avoiding a potential flash of the element's original state)\n     *   2. As all independent transforms share a single transform animation, stopping\n     *      it synchronously would prevent subsequent transforms from handing off.\n     */\n    frame.render(cancelOptimisedAnimation);\n    /**\n     * Record the time of the first handoff. We call performance.now() once\n     * here and once in startOptimisedAnimation to ensure we're getting\n     * close to a frame-locked time. This keeps all animations in sync.\n     */\n    if (handoffFrameTime === undefined) {\n      handoffFrameTime = performance.now();\n    }\n    /**\n     * We use main thread timings vs those returned by Animation.currentTime as it\n     * can be the case, particularly in Firefox, that currentTime doesn't return\n     * an updated value for several frames, even as the animation plays smoothly via\n     * the GPU.\n     */\n    return handoffFrameTime - startTime || 0;\n  } else {\n    cancelOptimisedAnimation();\n    return 0;\n  }\n}\nexport { handoffOptimizedAppearAnimation };","map":null,"metadata":{},"sourceType":"module"}